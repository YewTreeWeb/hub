{"version":3,"sources":["lunr.js"],"names":["lunr","config","builder","Builder","pipeline","add","trimmer","stopWordFilter","stemmer","searchPipeline","call","build","version","utils","warn","global","message","console","asString","obj","toString","FieldRef","docRef","fieldName","stringValue","_stringValue","joiner","fromString","s","n","indexOf","fieldRef","slice","prototype","undefined","idf","posting","documentCount","documentsWithTerm","Object","keys","length","x","Math","log","abs","Token","str","metadata","update","fn","clone","tokenizer","Array","isArray","map","t","toLowerCase","trim","len","tokens","sliceEnd","sliceStart","char","charAt","sliceLength","match","separator","push","position","index","Pipeline","_stack","registeredFunctions","create","registerFunction","label","warnIfFunctionNotRegistered","isRegistered","load","serialised","forEach","fnName","Error","fns","arguments","after","existingFn","newFn","pos","splice","before","remove","run","stackLength","i","reduce","memo","token","j","result","concat","runString","reset","toJSON","Vector","elements","_magnitude","positionForIndex","start","end","pivotPoint","floor","pivotIndex","insert","insertIdx","val","upsert","magnitude","sumOfSquares","elementsLength","sqrt","dot","otherVector","dotProduct","a","b","aLen","bLen","aVal","bVal","similarity","toArray","output","step2list","step3list","c","v","C","V","mgr0","meq1","mgr1","s_v","re_mgr0","RegExp","re_mgr1","re_meq1","re_s_v","re_1a","re2_1a","re_1b","re2_1b","re_1b_2","re2_1b_2","re3_1b_2","re4_1b_2","re_1c","re_2","re_3","re_4","re2_4","re_5","re_5_1","re3_5","porterStemmer","w","stem","suffix","firstch","re","re2","re3","re4","substr","toUpperCase","test","replace","fp","exec","generateStopWordFilter","stopWords","words","stopWord","TokenSet","final","edges","id","_nextId","fromArray","arr","finish","root","fromClause","clause","fromFuzzyString","term","editDistance","stack","node","editsRemaining","frame","pop","noEditNode","deletionNode","substitutionNode","insertionNode","charA","charB","transposeNode","wildcardFound","next","prefix","edge","_str","labels","sort","intersect","qNode","qEdges","qLen","nEdges","nLen","q","qEdge","nEdge","previousWord","uncheckedNodes","minimizedNodes","word","commonPrefix","minimize","child","nextNode","parent","downTo","childKey","Index","attrs","invertedIndex","fieldVectors","tokenSet","fields","search","queryString","query","parser","QueryParser","parse","Query","matchingFields","queryVectors","termFieldCache","clauses","terms","usePipeline","m","termTokenSet","expandedTerms","expandedTerm","termIndex","_index","k","field","fieldPosting","matchingDocumentRefs","termField","boost","l","matchingDocumentRef","matchingFieldRef","fieldMatch","MatchData","matchingFieldRefs","results","matches","fieldVector","score","docMatch","matchData","combine","ref","serializedIndex","serializedVectors","serializedInvertedIndex","tokenSetBuilder","tuple","_ref","_fields","fieldTermFrequencies","fieldLengths","_b","_k1","metadataWhitelist","number","k1","doc","fieldTerms","metadataKey","calculateAverageFieldLengths","fieldRefs","numberOfFields","accumulator","documentsWithField","averageFieldLength","createFieldVectors","fieldRefsLength","termIdfCache","fieldLength","termFrequencies","termsLength","tf","scoreWithPrecision","round","createTokenSet","use","args","unshift","apply","clonedMetadata","metadataKeys","key","otherMatchData","allFields","wildcard","String","NONE","LEADING","TRAILING","options","QueryParseError","name","QueryLexer","lexemes","escapeCharPositions","state","lexText","sliceString","subSlices","join","emit","type","escapeCharacter","EOS","width","ignore","backup","acceptDigitRun","charCode","charCodeAt","more","FIELD","TERM","EDIT_DISTANCE","BOOST","lexField","lexer","lexTerm","lexEditDistance","lexBoost","lexEOS","termSeparator","currentClause","lexemeIdx","parseFieldOrTerm","peekLexeme","consumeLexeme","lexeme","nextClause","completedClause","parseField","parseTerm","errorMessage","possibleFields","f","nextLexeme","parseEditDistance","parseBoost","parseInt","isNaN","factory","define","amd","exports","module"],"mappings":"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","file":"../lunr.js","sourcesContent":["/**\n * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.1.5\n * Copyright (C) 2017 Oliver Nightingale\n * @license MIT\n */\n\n;(function () {\n\n  /**\n   * A convenience function for configuring and constructing\n   * a new lunr Index.\n   *\n   * A lunr.Builder instance is created and the pipeline setup\n   * with a trimmer, stop word filter and stemmer.\n   *\n   * This builder object is yielded to the configuration function\n   * that is passed as a parameter, allowing the list of fields\n   * and other builder parameters to be customised.\n   *\n   * All documents _must_ be added within the passed config function.\n   *\n   * @example\n   * var idx = lunr(function () {\n   *   this.field('title')\n   *   this.field('body')\n   *   this.ref('id')\n   *\n   *   documents.forEach(function (doc) {\n   *     this.add(doc)\n   *   }, this)\n   * })\n   *\n   * @see {@link lunr.Builder}\n   * @see {@link lunr.Pipeline}\n   * @see {@link lunr.trimmer}\n   * @see {@link lunr.stopWordFilter}\n   * @see {@link lunr.stemmer}\n   * @namespace {function} lunr\n   */\n  var lunr = function (config) {\n    var builder = new lunr.Builder();\n\n    builder.pipeline.add(lunr.trimmer, lunr.stopWordFilter, lunr.stemmer);\n\n    builder.searchPipeline.add(lunr.stemmer);\n\n    config.call(builder, builder);\n    return builder.build();\n  };\n\n  lunr.version = \"2.1.5\";\n  /*!\n   * lunr.utils\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * A namespace containing utils for the rest of the lunr library\n   */\n  lunr.utils = {};\n\n  /**\n   * Print a warning message to the console.\n   *\n   * @param {String} message The message to be printed.\n   * @memberOf Utils\n   */\n  lunr.utils.warn = function (global) {\n    /* eslint-disable no-console */\n    return function (message) {\n      if (global.console && console.warn) {\n        console.warn(message);\n      }\n    };\n    /* eslint-enable no-console */\n  }(this);\n\n  /**\n   * Convert an object to a string.\n   *\n   * In the case of `null` and `undefined` the function returns\n   * the empty string, in all other cases the result of calling\n   * `toString` on the passed object is returned.\n   *\n   * @param {Any} obj The object to convert to a string.\n   * @return {String} string representation of the passed object.\n   * @memberOf Utils\n   */\n  lunr.utils.asString = function (obj) {\n    if (obj === void 0 || obj === null) {\n      return \"\";\n    } else {\n      return obj.toString();\n    }\n  };\n  lunr.FieldRef = function (docRef, fieldName, stringValue) {\n    this.docRef = docRef;\n    this.fieldName = fieldName;\n    this._stringValue = stringValue;\n  };\n\n  lunr.FieldRef.joiner = \"/\";\n\n  lunr.FieldRef.fromString = function (s) {\n    var n = s.indexOf(lunr.FieldRef.joiner);\n\n    if (n === -1) {\n      throw \"malformed field ref string\";\n    }\n\n    var fieldRef = s.slice(0, n),\n        docRef = s.slice(n + 1);\n\n    return new lunr.FieldRef(docRef, fieldRef, s);\n  };\n\n  lunr.FieldRef.prototype.toString = function () {\n    if (this._stringValue == undefined) {\n      this._stringValue = this.fieldName + lunr.FieldRef.joiner + this.docRef;\n    }\n\n    return this._stringValue;\n  };\n  /**\n   * A function to calculate the inverse document frequency for\n   * a posting. This is shared between the builder and the index\n   *\n   * @private\n   * @param {object} posting - The posting for a given term\n   * @param {number} documentCount - The total number of documents.\n   */\n  lunr.idf = function (posting, documentCount) {\n    var documentsWithTerm = 0;\n\n    for (var fieldName in posting) {\n      if (fieldName == '_index') continue; // Ignore the term index, its not a field\n      documentsWithTerm += Object.keys(posting[fieldName]).length;\n    }\n\n    var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5);\n\n    return Math.log(1 + Math.abs(x));\n  };\n\n  /**\n   * A token wraps a string representation of a token\n   * as it is passed through the text processing pipeline.\n   *\n   * @constructor\n   * @param {string} [str=''] - The string token being wrapped.\n   * @param {object} [metadata={}] - Metadata associated with this token.\n   */\n  lunr.Token = function (str, metadata) {\n    this.str = str || \"\";\n    this.metadata = metadata || {};\n  };\n\n  /**\n   * Returns the token string that is being wrapped by this object.\n   *\n   * @returns {string}\n   */\n  lunr.Token.prototype.toString = function () {\n    return this.str;\n  };\n\n  /**\n   * A token update function is used when updating or optionally\n   * when cloning a token.\n   *\n   * @callback lunr.Token~updateFunction\n   * @param {string} str - The string representation of the token.\n   * @param {Object} metadata - All metadata associated with this token.\n   */\n\n  /**\n   * Applies the given function to the wrapped string token.\n   *\n   * @example\n   * token.update(function (str, metadata) {\n   *   return str.toUpperCase()\n   * })\n   *\n   * @param {lunr.Token~updateFunction} fn - A function to apply to the token string.\n   * @returns {lunr.Token}\n   */\n  lunr.Token.prototype.update = function (fn) {\n    this.str = fn(this.str, this.metadata);\n    return this;\n  };\n\n  /**\n   * Creates a clone of this token. Optionally a function can be\n   * applied to the cloned token.\n   *\n   * @param {lunr.Token~updateFunction} [fn] - An optional function to apply to the cloned token.\n   * @returns {lunr.Token}\n   */\n  lunr.Token.prototype.clone = function (fn) {\n    fn = fn || function (s) {\n      return s;\n    };\n    return new lunr.Token(fn(this.str, this.metadata), this.metadata);\n  };\n  /*!\n   * lunr.tokenizer\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * A function for splitting a string into tokens ready to be inserted into\n   * the search index. Uses `lunr.tokenizer.separator` to split strings, change\n   * the value of this property to change how strings are split into tokens.\n   *\n   * This tokenizer will convert its parameter to a string by calling `toString` and\n   * then will split this string on the character in `lunr.tokenizer.separator`.\n   * Arrays will have their elements converted to strings and wrapped in a lunr.Token.\n   *\n   * @static\n   * @param {?(string|object|object[])} obj - The object to convert into tokens\n   * @returns {lunr.Token[]}\n   */\n  lunr.tokenizer = function (obj) {\n    if (obj == null || obj == undefined) {\n      return [];\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(function (t) {\n        return new lunr.Token(lunr.utils.asString(t).toLowerCase());\n      });\n    }\n\n    var str = obj.toString().trim().toLowerCase(),\n        len = str.length,\n        tokens = [];\n\n    for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {\n      var char = str.charAt(sliceEnd),\n          sliceLength = sliceEnd - sliceStart;\n\n      if (char.match(lunr.tokenizer.separator) || sliceEnd == len) {\n\n        if (sliceLength > 0) {\n          tokens.push(new lunr.Token(str.slice(sliceStart, sliceEnd), {\n            position: [sliceStart, sliceLength],\n            index: tokens.length\n          }));\n        }\n\n        sliceStart = sliceEnd + 1;\n      }\n    }\n\n    return tokens;\n  };\n\n  /**\n   * The separator used to split a string into tokens. Override this property to change the behaviour of\n   * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.\n   *\n   * @static\n   * @see lunr.tokenizer\n   */\n  lunr.tokenizer.separator = /[\\s\\-]+/;\n  /*!\n   * lunr.Pipeline\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * lunr.Pipelines maintain an ordered list of functions to be applied to all\n   * tokens in documents entering the search index and queries being ran against\n   * the index.\n   *\n   * An instance of lunr.Index created with the lunr shortcut will contain a\n   * pipeline with a stop word filter and an English language stemmer. Extra\n   * functions can be added before or after either of these functions or these\n   * default functions can be removed.\n   *\n   * When run the pipeline will call each function in turn, passing a token, the\n   * index of that token in the original list of all tokens and finally a list of\n   * all the original tokens.\n   *\n   * The output of functions in the pipeline will be passed to the next function\n   * in the pipeline. To exclude a token from entering the index the function\n   * should return undefined, the rest of the pipeline will not be called with\n   * this token.\n   *\n   * For serialisation of pipelines to work, all functions used in an instance of\n   * a pipeline should be registered with lunr.Pipeline. Registered functions can\n   * then be loaded. If trying to load a serialised pipeline that uses functions\n   * that are not registered an error will be thrown.\n   *\n   * If not planning on serialising the pipeline then registering pipeline functions\n   * is not necessary.\n   *\n   * @constructor\n   */\n  lunr.Pipeline = function () {\n    this._stack = [];\n  };\n\n  lunr.Pipeline.registeredFunctions = Object.create(null);\n\n  /**\n   * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token\n   * string as well as all known metadata. A pipeline function can mutate the token string\n   * or mutate (or add) metadata for a given token.\n   *\n   * A pipeline function can indicate that the passed token should be discarded by returning\n   * null. This token will not be passed to any downstream pipeline functions and will not be\n   * added to the index.\n   *\n   * Multiple tokens can be returned by returning an array of tokens. Each token will be passed\n   * to any downstream pipeline functions and all will returned tokens will be added to the index.\n   *\n   * Any number of pipeline functions may be chained together using a lunr.Pipeline.\n   *\n   * @interface lunr.PipelineFunction\n   * @param {lunr.Token} token - A token from the document being processed.\n   * @param {number} i - The index of this token in the complete list of tokens for this document/field.\n   * @param {lunr.Token[]} tokens - All tokens for this document/field.\n   * @returns {(?lunr.Token|lunr.Token[])}\n   */\n\n  /**\n   * Register a function with the pipeline.\n   *\n   * Functions that are used in the pipeline should be registered if the pipeline\n   * needs to be serialised, or a serialised pipeline needs to be loaded.\n   *\n   * Registering a function does not add it to a pipeline, functions must still be\n   * added to instances of the pipeline for them to be used when running a pipeline.\n   *\n   * @param {lunr.PipelineFunction} fn - The function to check for.\n   * @param {String} label - The label to register this function with\n   */\n  lunr.Pipeline.registerFunction = function (fn, label) {\n    if (label in this.registeredFunctions) {\n      lunr.utils.warn('Overwriting existing registered function: ' + label);\n    }\n\n    fn.label = label;\n    lunr.Pipeline.registeredFunctions[fn.label] = fn;\n  };\n\n  /**\n   * Warns if the function is not registered as a Pipeline function.\n   *\n   * @param {lunr.PipelineFunction} fn - The function to check for.\n   * @private\n   */\n  lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {\n    var isRegistered = fn.label && fn.label in this.registeredFunctions;\n\n    if (!isRegistered) {\n      lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn);\n    }\n  };\n\n  /**\n   * Loads a previously serialised pipeline.\n   *\n   * All functions to be loaded must already be registered with lunr.Pipeline.\n   * If any function from the serialised data has not been registered then an\n   * error will be thrown.\n   *\n   * @param {Object} serialised - The serialised pipeline to load.\n   * @returns {lunr.Pipeline}\n   */\n  lunr.Pipeline.load = function (serialised) {\n    var pipeline = new lunr.Pipeline();\n\n    serialised.forEach(function (fnName) {\n      var fn = lunr.Pipeline.registeredFunctions[fnName];\n\n      if (fn) {\n        pipeline.add(fn);\n      } else {\n        throw new Error('Cannot load unregistered function: ' + fnName);\n      }\n    });\n\n    return pipeline;\n  };\n\n  /**\n   * Adds new functions to the end of the pipeline.\n   *\n   * Logs a warning if the function has not been registered.\n   *\n   * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline.\n   */\n  lunr.Pipeline.prototype.add = function () {\n    var fns = Array.prototype.slice.call(arguments);\n\n    fns.forEach(function (fn) {\n      lunr.Pipeline.warnIfFunctionNotRegistered(fn);\n      this._stack.push(fn);\n    }, this);\n  };\n\n  /**\n   * Adds a single function after a function that already exists in the\n   * pipeline.\n   *\n   * Logs a warning if the function has not been registered.\n   *\n   * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.\n   * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.\n   */\n  lunr.Pipeline.prototype.after = function (existingFn, newFn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n\n    var pos = this._stack.indexOf(existingFn);\n    if (pos == -1) {\n      throw new Error('Cannot find existingFn');\n    }\n\n    pos = pos + 1;\n    this._stack.splice(pos, 0, newFn);\n  };\n\n  /**\n   * Adds a single function before a function that already exists in the\n   * pipeline.\n   *\n   * Logs a warning if the function has not been registered.\n   *\n   * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.\n   * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.\n   */\n  lunr.Pipeline.prototype.before = function (existingFn, newFn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n\n    var pos = this._stack.indexOf(existingFn);\n    if (pos == -1) {\n      throw new Error('Cannot find existingFn');\n    }\n\n    this._stack.splice(pos, 0, newFn);\n  };\n\n  /**\n   * Removes a function from the pipeline.\n   *\n   * @param {lunr.PipelineFunction} fn The function to remove from the pipeline.\n   */\n  lunr.Pipeline.prototype.remove = function (fn) {\n    var pos = this._stack.indexOf(fn);\n    if (pos == -1) {\n      return;\n    }\n\n    this._stack.splice(pos, 1);\n  };\n\n  /**\n   * Runs the current list of functions that make up the pipeline against the\n   * passed tokens.\n   *\n   * @param {Array} tokens The tokens to run through the pipeline.\n   * @returns {Array}\n   */\n  lunr.Pipeline.prototype.run = function (tokens) {\n    var stackLength = this._stack.length;\n\n    for (var i = 0; i < stackLength; i++) {\n      var fn = this._stack[i];\n\n      tokens = tokens.reduce(function (memo, token, j) {\n        var result = fn(token, j, tokens);\n\n        if (result === void 0 || result === '') return memo;\n\n        return memo.concat(result);\n      }, []);\n    }\n\n    return tokens;\n  };\n\n  /**\n   * Convenience method for passing a string through a pipeline and getting\n   * strings out. This method takes care of wrapping the passed string in a\n   * token and mapping the resulting tokens back to strings.\n   *\n   * @param {string} str - The string to pass through the pipeline.\n   * @returns {string[]}\n   */\n  lunr.Pipeline.prototype.runString = function (str) {\n    var token = new lunr.Token(str);\n\n    return this.run([token]).map(function (t) {\n      return t.toString();\n    });\n  };\n\n  /**\n   * Resets the pipeline by removing any existing processors.\n   *\n   */\n  lunr.Pipeline.prototype.reset = function () {\n    this._stack = [];\n  };\n\n  /**\n   * Returns a representation of the pipeline ready for serialisation.\n   *\n   * Logs a warning if the function has not been registered.\n   *\n   * @returns {Array}\n   */\n  lunr.Pipeline.prototype.toJSON = function () {\n    return this._stack.map(function (fn) {\n      lunr.Pipeline.warnIfFunctionNotRegistered(fn);\n\n      return fn.label;\n    });\n  };\n  /*!\n   * lunr.Vector\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * A vector is used to construct the vector space of documents and queries. These\n   * vectors support operations to determine the similarity between two documents or\n   * a document and a query.\n   *\n   * Normally no parameters are required for initializing a vector, but in the case of\n   * loading a previously dumped vector the raw elements can be provided to the constructor.\n   *\n   * For performance reasons vectors are implemented with a flat array, where an elements\n   * index is immediately followed by its value. E.g. [index, value, index, value]. This\n   * allows the underlying array to be as sparse as possible and still offer decent\n   * performance when being used for vector calculations.\n   *\n   * @constructor\n   * @param {Number[]} [elements] - The flat list of element index and element value pairs.\n   */\n  lunr.Vector = function (elements) {\n    this._magnitude = 0;\n    this.elements = elements || [];\n  };\n\n  /**\n   * Calculates the position within the vector to insert a given index.\n   *\n   * This is used internally by insert and upsert. If there are duplicate indexes then\n   * the position is returned as if the value for that index were to be updated, but it\n   * is the callers responsibility to check whether there is a duplicate at that index\n   *\n   * @param {Number} insertIdx - The index at which the element should be inserted.\n   * @returns {Number}\n   */\n  lunr.Vector.prototype.positionForIndex = function (index) {\n    // For an empty vector the tuple can be inserted at the beginning\n    if (this.elements.length == 0) {\n      return 0;\n    }\n\n    var start = 0,\n        end = this.elements.length / 2,\n        sliceLength = end - start,\n        pivotPoint = Math.floor(sliceLength / 2),\n        pivotIndex = this.elements[pivotPoint * 2];\n\n    while (sliceLength > 1) {\n      if (pivotIndex < index) {\n        start = pivotPoint;\n      }\n\n      if (pivotIndex > index) {\n        end = pivotPoint;\n      }\n\n      if (pivotIndex == index) {\n        break;\n      }\n\n      sliceLength = end - start;\n      pivotPoint = start + Math.floor(sliceLength / 2);\n      pivotIndex = this.elements[pivotPoint * 2];\n    }\n\n    if (pivotIndex == index) {\n      return pivotPoint * 2;\n    }\n\n    if (pivotIndex > index) {\n      return pivotPoint * 2;\n    }\n\n    if (pivotIndex < index) {\n      return (pivotPoint + 1) * 2;\n    }\n  };\n\n  /**\n   * Inserts an element at an index within the vector.\n   *\n   * Does not allow duplicates, will throw an error if there is already an entry\n   * for this index.\n   *\n   * @param {Number} insertIdx - The index at which the element should be inserted.\n   * @param {Number} val - The value to be inserted into the vector.\n   */\n  lunr.Vector.prototype.insert = function (insertIdx, val) {\n    this.upsert(insertIdx, val, function () {\n      throw \"duplicate index\";\n    });\n  };\n\n  /**\n   * Inserts or updates an existing index within the vector.\n   *\n   * @param {Number} insertIdx - The index at which the element should be inserted.\n   * @param {Number} val - The value to be inserted into the vector.\n   * @param {function} fn - A function that is called for updates, the existing value and the\n   * requested value are passed as arguments\n   */\n  lunr.Vector.prototype.upsert = function (insertIdx, val, fn) {\n    this._magnitude = 0;\n    var position = this.positionForIndex(insertIdx);\n\n    if (this.elements[position] == insertIdx) {\n      this.elements[position + 1] = fn(this.elements[position + 1], val);\n    } else {\n      this.elements.splice(position, 0, insertIdx, val);\n    }\n  };\n\n  /**\n   * Calculates the magnitude of this vector.\n   *\n   * @returns {Number}\n   */\n  lunr.Vector.prototype.magnitude = function () {\n    if (this._magnitude) return this._magnitude;\n\n    var sumOfSquares = 0,\n        elementsLength = this.elements.length;\n\n    for (var i = 1; i < elementsLength; i += 2) {\n      var val = this.elements[i];\n      sumOfSquares += val * val;\n    }\n\n    return this._magnitude = Math.sqrt(sumOfSquares);\n  };\n\n  /**\n   * Calculates the dot product of this vector and another vector.\n   *\n   * @param {lunr.Vector} otherVector - The vector to compute the dot product with.\n   * @returns {Number}\n   */\n  lunr.Vector.prototype.dot = function (otherVector) {\n    var dotProduct = 0,\n        a = this.elements,\n        b = otherVector.elements,\n        aLen = a.length,\n        bLen = b.length,\n        aVal = 0,\n        bVal = 0,\n        i = 0,\n        j = 0;\n\n    while (i < aLen && j < bLen) {\n      aVal = a[i], bVal = b[j];\n      if (aVal < bVal) {\n        i += 2;\n      } else if (aVal > bVal) {\n        j += 2;\n      } else if (aVal == bVal) {\n        dotProduct += a[i + 1] * b[j + 1];\n        i += 2;\n        j += 2;\n      }\n    }\n\n    return dotProduct;\n  };\n\n  /**\n   * Calculates the cosine similarity between this vector and another\n   * vector.\n   *\n   * @param {lunr.Vector} otherVector - The other vector to calculate the\n   * similarity with.\n   * @returns {Number}\n   */\n  lunr.Vector.prototype.similarity = function (otherVector) {\n    return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude());\n  };\n\n  /**\n   * Converts the vector to an array of the elements within the vector.\n   *\n   * @returns {Number[]}\n   */\n  lunr.Vector.prototype.toArray = function () {\n    var output = new Array(this.elements.length / 2);\n\n    for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {\n      output[j] = this.elements[i];\n    }\n\n    return output;\n  };\n\n  /**\n   * A JSON serializable representation of the vector.\n   *\n   * @returns {Number[]}\n   */\n  lunr.Vector.prototype.toJSON = function () {\n    return this.elements;\n  };\n  /* eslint-disable */\n  /*!\n   * lunr.stemmer\n   * Copyright (C) 2017 Oliver Nightingale\n   * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n   */\n\n  /**\n   * lunr.stemmer is an english language stemmer, this is a JavaScript\n   * implementation of the PorterStemmer taken from http://tartarus.org/~martin\n   *\n   * @static\n   * @implements {lunr.PipelineFunction}\n   * @param {lunr.Token} token - The string to stem\n   * @returns {lunr.Token}\n   * @see {@link lunr.Pipeline}\n   */\n  lunr.stemmer = function () {\n    var step2list = {\n      \"ational\": \"ate\",\n      \"tional\": \"tion\",\n      \"enci\": \"ence\",\n      \"anci\": \"ance\",\n      \"izer\": \"ize\",\n      \"bli\": \"ble\",\n      \"alli\": \"al\",\n      \"entli\": \"ent\",\n      \"eli\": \"e\",\n      \"ousli\": \"ous\",\n      \"ization\": \"ize\",\n      \"ation\": \"ate\",\n      \"ator\": \"ate\",\n      \"alism\": \"al\",\n      \"iveness\": \"ive\",\n      \"fulness\": \"ful\",\n      \"ousness\": \"ous\",\n      \"aliti\": \"al\",\n      \"iviti\": \"ive\",\n      \"biliti\": \"ble\",\n      \"logi\": \"log\"\n    },\n        step3list = {\n      \"icate\": \"ic\",\n      \"ative\": \"\",\n      \"alize\": \"al\",\n      \"iciti\": \"ic\",\n      \"ical\": \"ic\",\n      \"ful\": \"\",\n      \"ness\": \"\"\n    },\n        c = \"[^aeiou]\",\n\n\n    // consonant\n    v = \"[aeiouy]\",\n\n\n    // vowel\n    C = c + \"[^aeiouy]*\",\n\n\n    // consonant sequence\n    V = v + \"[aeiou]*\",\n\n\n    // vowel sequence\n\n    mgr0 = \"^(\" + C + \")?\" + V + C,\n\n\n    // [C]VC... is m>0\n    meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\",\n\n\n    // [C]VC[V] is m=1\n    mgr1 = \"^(\" + C + \")?\" + V + C + V + C,\n\n\n    // [C]VCVC... is m>1\n    s_v = \"^(\" + C + \")?\" + v; // vowel in stem\n\n    var re_mgr0 = new RegExp(mgr0);\n    var re_mgr1 = new RegExp(mgr1);\n    var re_meq1 = new RegExp(meq1);\n    var re_s_v = new RegExp(s_v);\n\n    var re_1a = /^(.+?)(ss|i)es$/;\n    var re2_1a = /^(.+?)([^s])s$/;\n    var re_1b = /^(.+?)eed$/;\n    var re2_1b = /^(.+?)(ed|ing)$/;\n    var re_1b_2 = /.$/;\n    var re2_1b_2 = /(at|bl|iz)$/;\n    var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n    var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n    var re_1c = /^(.+?[^aeiou])y$/;\n    var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n\n    var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n\n    var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n    var re2_4 = /^(.+?)(s|t)(ion)$/;\n\n    var re_5 = /^(.+?)e$/;\n    var re_5_1 = /ll$/;\n    var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n    var porterStemmer = function porterStemmer(w) {\n      var stem, suffix, firstch, re, re2, re3, re4;\n\n      if (w.length < 3) {\n        return w;\n      }\n\n      firstch = w.substr(0, 1);\n      if (firstch == \"y\") {\n        w = firstch.toUpperCase() + w.substr(1);\n      }\n\n      // Step 1a\n      re = re_1a;\n      re2 = re2_1a;\n\n      if (re.test(w)) {\n        w = w.replace(re, \"$1$2\");\n      } else if (re2.test(w)) {\n        w = w.replace(re2, \"$1$2\");\n      }\n\n      // Step 1b\n      re = re_1b;\n      re2 = re2_1b;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        re = re_mgr0;\n        if (re.test(fp[1])) {\n          re = re_1b_2;\n          w = w.replace(re, \"\");\n        }\n      } else if (re2.test(w)) {\n        var fp = re2.exec(w);\n        stem = fp[1];\n        re2 = re_s_v;\n        if (re2.test(stem)) {\n          w = stem;\n          re2 = re2_1b_2;\n          re3 = re3_1b_2;\n          re4 = re4_1b_2;\n          if (re2.test(w)) {\n            w = w + \"e\";\n          } else if (re3.test(w)) {\n            re = re_1b_2;w = w.replace(re, \"\");\n          } else if (re4.test(w)) {\n            w = w + \"e\";\n          }\n        }\n      }\n\n      // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)\n      re = re_1c;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        w = stem + \"i\";\n      }\n\n      // Step 2\n      re = re_2;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        suffix = fp[2];\n        re = re_mgr0;\n        if (re.test(stem)) {\n          w = stem + step2list[suffix];\n        }\n      }\n\n      // Step 3\n      re = re_3;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        suffix = fp[2];\n        re = re_mgr0;\n        if (re.test(stem)) {\n          w = stem + step3list[suffix];\n        }\n      }\n\n      // Step 4\n      re = re_4;\n      re2 = re2_4;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        re = re_mgr1;\n        if (re.test(stem)) {\n          w = stem;\n        }\n      } else if (re2.test(w)) {\n        var fp = re2.exec(w);\n        stem = fp[1] + fp[2];\n        re2 = re_mgr1;\n        if (re2.test(stem)) {\n          w = stem;\n        }\n      }\n\n      // Step 5\n      re = re_5;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        re = re_mgr1;\n        re2 = re_meq1;\n        re3 = re3_5;\n        if (re.test(stem) || re2.test(stem) && !re3.test(stem)) {\n          w = stem;\n        }\n      }\n\n      re = re_5_1;\n      re2 = re_mgr1;\n      if (re.test(w) && re2.test(w)) {\n        re = re_1b_2;\n        w = w.replace(re, \"\");\n      }\n\n      // and turn initial Y back to y\n\n      if (firstch == \"y\") {\n        w = firstch.toLowerCase() + w.substr(1);\n      }\n\n      return w;\n    };\n\n    return function (token) {\n      return token.update(porterStemmer);\n    };\n  }();\n\n  lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer');\n  /*!\n   * lunr.stopWordFilter\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * lunr.generateStopWordFilter builds a stopWordFilter function from the provided\n   * list of stop words.\n   *\n   * The built in lunr.stopWordFilter is built using this generator and can be used\n   * to generate custom stopWordFilters for applications or non English languages.\n   *\n   * @param {Array} token The token to pass through the filter\n   * @returns {lunr.PipelineFunction}\n   * @see lunr.Pipeline\n   * @see lunr.stopWordFilter\n   */\n  lunr.generateStopWordFilter = function (stopWords) {\n    var words = stopWords.reduce(function (memo, stopWord) {\n      memo[stopWord] = stopWord;\n      return memo;\n    }, {});\n\n    return function (token) {\n      if (token && words[token.toString()] !== token.toString()) return token;\n    };\n  };\n\n  /**\n   * lunr.stopWordFilter is an English language stop word list filter, any words\n   * contained in the list will not be passed through the filter.\n   *\n   * This is intended to be used in the Pipeline. If the token does not pass the\n   * filter then undefined will be returned.\n   *\n   * @implements {lunr.PipelineFunction}\n   * @params {lunr.Token} token - A token to check for being a stop word.\n   * @returns {lunr.Token}\n   * @see {@link lunr.Pipeline}\n   */\n  lunr.stopWordFilter = lunr.generateStopWordFilter(['a', 'able', 'about', 'across', 'after', 'all', 'almost', 'also', 'am', 'among', 'an', 'and', 'any', 'are', 'as', 'at', 'be', 'because', 'been', 'but', 'by', 'can', 'cannot', 'could', 'dear', 'did', 'do', 'does', 'either', 'else', 'ever', 'every', 'for', 'from', 'get', 'got', 'had', 'has', 'have', 'he', 'her', 'hers', 'him', 'his', 'how', 'however', 'i', 'if', 'in', 'into', 'is', 'it', 'its', 'just', 'least', 'let', 'like', 'likely', 'may', 'me', 'might', 'most', 'must', 'my', 'neither', 'no', 'nor', 'not', 'of', 'off', 'often', 'on', 'only', 'or', 'other', 'our', 'own', 'rather', 'said', 'say', 'says', 'she', 'should', 'since', 'so', 'some', 'than', 'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'tis', 'to', 'too', 'twas', 'us', 'wants', 'was', 'we', 'were', 'what', 'when', 'where', 'which', 'while', 'who', 'whom', 'why', 'will', 'with', 'would', 'yet', 'you', 'your']);\n\n  lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter');\n  /*!\n   * lunr.trimmer\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * lunr.trimmer is a pipeline function for trimming non word\n   * characters from the beginning and end of tokens before they\n   * enter the index.\n   *\n   * This implementation may not work correctly for non latin\n   * characters and should either be removed or adapted for use\n   * with languages with non-latin characters.\n   *\n   * @static\n   * @implements {lunr.PipelineFunction}\n   * @param {lunr.Token} token The token to pass through the filter\n   * @returns {lunr.Token}\n   * @see lunr.Pipeline\n   */\n  lunr.trimmer = function (token) {\n    return token.update(function (s) {\n      return s.replace(/^\\W+/, '').replace(/\\W+$/, '');\n    });\n  };\n\n  lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer');\n  /*!\n   * lunr.TokenSet\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * A token set is used to store the unique list of all tokens\n   * within an index. Token sets are also used to represent an\n   * incoming query to the index, this query token set and index\n   * token set are then intersected to find which tokens to look\n   * up in the inverted index.\n   *\n   * A token set can hold multiple tokens, as in the case of the\n   * index token set, or it can hold a single token as in the\n   * case of a simple query token set.\n   *\n   * Additionally token sets are used to perform wildcard matching.\n   * Leading, contained and trailing wildcards are supported, and\n   * from this edit distance matching can also be provided.\n   *\n   * Token sets are implemented as a minimal finite state automata,\n   * where both common prefixes and suffixes are shared between tokens.\n   * This helps to reduce the space used for storing the token set.\n   *\n   * @constructor\n   */\n  lunr.TokenSet = function () {\n    this.final = false;\n    this.edges = {};\n    this.id = lunr.TokenSet._nextId;\n    lunr.TokenSet._nextId += 1;\n  };\n\n  /**\n   * Keeps track of the next, auto increment, identifier to assign\n   * to a new tokenSet.\n   *\n   * TokenSets require a unique identifier to be correctly minimised.\n   *\n   * @private\n   */\n  lunr.TokenSet._nextId = 1;\n\n  /**\n   * Creates a TokenSet instance from the given sorted array of words.\n   *\n   * @param {String[]} arr - A sorted array of strings to create the set from.\n   * @returns {lunr.TokenSet}\n   * @throws Will throw an error if the input array is not sorted.\n   */\n  lunr.TokenSet.fromArray = function (arr) {\n    var builder = new lunr.TokenSet.Builder();\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      builder.insert(arr[i]);\n    }\n\n    builder.finish();\n    return builder.root;\n  };\n\n  /**\n   * Creates a token set from a query clause.\n   *\n   * @private\n   * @param {Object} clause - A single clause from lunr.Query.\n   * @param {string} clause.term - The query clause term.\n   * @param {number} [clause.editDistance] - The optional edit distance for the term.\n   * @returns {lunr.TokenSet}\n   */\n  lunr.TokenSet.fromClause = function (clause) {\n    if ('editDistance' in clause) {\n      return lunr.TokenSet.fromFuzzyString(clause.term, clause.editDistance);\n    } else {\n      return lunr.TokenSet.fromString(clause.term);\n    }\n  };\n\n  /**\n   * Creates a token set representing a single string with a specified\n   * edit distance.\n   *\n   * Insertions, deletions, substitutions and transpositions are each\n   * treated as an edit distance of 1.\n   *\n   * Increasing the allowed edit distance will have a dramatic impact\n   * on the performance of both creating and intersecting these TokenSets.\n   * It is advised to keep the edit distance less than 3.\n   *\n   * @param {string} str - The string to create the token set from.\n   * @param {number} editDistance - The allowed edit distance to match.\n   * @returns {lunr.Vector}\n   */\n  lunr.TokenSet.fromFuzzyString = function (str, editDistance) {\n    var root = new lunr.TokenSet();\n\n    var stack = [{\n      node: root,\n      editsRemaining: editDistance,\n      str: str\n    }];\n\n    while (stack.length) {\n      var frame = stack.pop();\n\n      // no edit\n      if (frame.str.length > 0) {\n        var char = frame.str.charAt(0),\n            noEditNode;\n\n        if (char in frame.node.edges) {\n          noEditNode = frame.node.edges[char];\n        } else {\n          noEditNode = new lunr.TokenSet();\n          frame.node.edges[char] = noEditNode;\n        }\n\n        if (frame.str.length == 1) {\n          noEditNode.final = true;\n        } else {\n          stack.push({\n            node: noEditNode,\n            editsRemaining: frame.editsRemaining,\n            str: frame.str.slice(1)\n          });\n        }\n      }\n\n      // deletion\n      // can only do a deletion if we have enough edits remaining\n      // and if there are characters left to delete in the string\n      if (frame.editsRemaining > 0 && frame.str.length > 1) {\n        var char = frame.str.charAt(1),\n            deletionNode;\n\n        if (char in frame.node.edges) {\n          deletionNode = frame.node.edges[char];\n        } else {\n          deletionNode = new lunr.TokenSet();\n          frame.node.edges[char] = deletionNode;\n        }\n\n        if (frame.str.length <= 2) {\n          deletionNode.final = true;\n        } else {\n          stack.push({\n            node: deletionNode,\n            editsRemaining: frame.editsRemaining - 1,\n            str: frame.str.slice(2)\n          });\n        }\n      }\n\n      // deletion\n      // just removing the last character from the str\n      if (frame.editsRemaining > 0 && frame.str.length == 1) {\n        frame.node.final = true;\n      }\n\n      // substitution\n      // can only do a substitution if we have enough edits remaining\n      // and if there are characters left to substitute\n      if (frame.editsRemaining > 0 && frame.str.length >= 1) {\n        if (\"*\" in frame.node.edges) {\n          var substitutionNode = frame.node.edges[\"*\"];\n        } else {\n          var substitutionNode = new lunr.TokenSet();\n          frame.node.edges[\"*\"] = substitutionNode;\n        }\n\n        if (frame.str.length == 1) {\n          substitutionNode.final = true;\n        } else {\n          stack.push({\n            node: substitutionNode,\n            editsRemaining: frame.editsRemaining - 1,\n            str: frame.str.slice(1)\n          });\n        }\n      }\n\n      // insertion\n      // can only do insertion if there are edits remaining\n      if (frame.editsRemaining > 0) {\n        if (\"*\" in frame.node.edges) {\n          var insertionNode = frame.node.edges[\"*\"];\n        } else {\n          var insertionNode = new lunr.TokenSet();\n          frame.node.edges[\"*\"] = insertionNode;\n        }\n\n        if (frame.str.length == 0) {\n          insertionNode.final = true;\n        } else {\n          stack.push({\n            node: insertionNode,\n            editsRemaining: frame.editsRemaining - 1,\n            str: frame.str\n          });\n        }\n      }\n\n      // transposition\n      // can only do a transposition if there are edits remaining\n      // and there are enough characters to transpose\n      if (frame.editsRemaining > 0 && frame.str.length > 1) {\n        var charA = frame.str.charAt(0),\n            charB = frame.str.charAt(1),\n            transposeNode;\n\n        if (charB in frame.node.edges) {\n          transposeNode = frame.node.edges[charB];\n        } else {\n          transposeNode = new lunr.TokenSet();\n          frame.node.edges[charB] = transposeNode;\n        }\n\n        if (frame.str.length == 1) {\n          transposeNode.final = true;\n        } else {\n          stack.push({\n            node: transposeNode,\n            editsRemaining: frame.editsRemaining - 1,\n            str: charA + frame.str.slice(2)\n          });\n        }\n      }\n    }\n\n    return root;\n  };\n\n  /**\n   * Creates a TokenSet from a string.\n   *\n   * The string may contain one or more wildcard characters (*)\n   * that will allow wildcard matching when intersecting with\n   * another TokenSet.\n   *\n   * @param {string} str - The string to create a TokenSet from.\n   * @returns {lunr.TokenSet}\n   */\n  lunr.TokenSet.fromString = function (str) {\n    var node = new lunr.TokenSet(),\n        root = node,\n        wildcardFound = false;\n\n    /*\n     * Iterates through all characters within the passed string\n     * appending a node for each character.\n     *\n     * As soon as a wildcard character is found then a self\n     * referencing edge is introduced to continually match\n     * any number of any characters.\n     */\n    for (var i = 0, len = str.length; i < len; i++) {\n      var char = str[i],\n          final = i == len - 1;\n\n      if (char == \"*\") {\n        wildcardFound = true;\n        node.edges[char] = node;\n        node.final = final;\n      } else {\n        var next = new lunr.TokenSet();\n        next.final = final;\n\n        node.edges[char] = next;\n        node = next;\n\n        // TODO: is this needed anymore?\n        if (wildcardFound) {\n          node.edges[\"*\"] = root;\n        }\n      }\n    }\n\n    return root;\n  };\n\n  /**\n   * Converts this TokenSet into an array of strings\n   * contained within the TokenSet.\n   *\n   * @returns {string[]}\n   */\n  lunr.TokenSet.prototype.toArray = function () {\n    var words = [];\n\n    var stack = [{\n      prefix: \"\",\n      node: this\n    }];\n\n    while (stack.length) {\n      var frame = stack.pop(),\n          edges = Object.keys(frame.node.edges),\n          len = edges.length;\n\n      if (frame.node.final) {\n        words.push(frame.prefix);\n      }\n\n      for (var i = 0; i < len; i++) {\n        var edge = edges[i];\n\n        stack.push({\n          prefix: frame.prefix.concat(edge),\n          node: frame.node.edges[edge]\n        });\n      }\n    }\n\n    return words;\n  };\n\n  /**\n   * Generates a string representation of a TokenSet.\n   *\n   * This is intended to allow TokenSets to be used as keys\n   * in objects, largely to aid the construction and minimisation\n   * of a TokenSet. As such it is not designed to be a human\n   * friendly representation of the TokenSet.\n   *\n   * @returns {string}\n   */\n  lunr.TokenSet.prototype.toString = function () {\n    // NOTE: Using Object.keys here as this.edges is very likely\n    // to enter 'hash-mode' with many keys being added\n    //\n    // avoiding a for-in loop here as it leads to the function\n    // being de-optimised (at least in V8). From some simple\n    // benchmarks the performance is comparable, but allowing\n    // V8 to optimize may mean easy performance wins in the future.\n\n    if (this._str) {\n      return this._str;\n    }\n\n    var str = this.final ? '1' : '0',\n        labels = Object.keys(this.edges).sort(),\n        len = labels.length;\n\n    for (var i = 0; i < len; i++) {\n      var label = labels[i],\n          node = this.edges[label];\n\n      str = str + label + node.id;\n    }\n\n    return str;\n  };\n\n  /**\n   * Returns a new TokenSet that is the intersection of\n   * this TokenSet and the passed TokenSet.\n   *\n   * This intersection will take into account any wildcards\n   * contained within the TokenSet.\n   *\n   * @param {lunr.TokenSet} b - An other TokenSet to intersect with.\n   * @returns {lunr.TokenSet}\n   */\n  lunr.TokenSet.prototype.intersect = function (b) {\n    var output = new lunr.TokenSet(),\n        frame = undefined;\n\n    var stack = [{\n      qNode: b,\n      output: output,\n      node: this\n    }];\n\n    while (stack.length) {\n      frame = stack.pop();\n\n      // NOTE: As with the #toString method, we are using\n      // Object.keys and a for loop instead of a for-in loop\n      // as both of these objects enter 'hash' mode, causing\n      // the function to be de-optimised in V8\n      var qEdges = Object.keys(frame.qNode.edges),\n          qLen = qEdges.length,\n          nEdges = Object.keys(frame.node.edges),\n          nLen = nEdges.length;\n\n      for (var q = 0; q < qLen; q++) {\n        var qEdge = qEdges[q];\n\n        for (var n = 0; n < nLen; n++) {\n          var nEdge = nEdges[n];\n\n          if (nEdge == qEdge || qEdge == '*') {\n            var node = frame.node.edges[nEdge],\n                qNode = frame.qNode.edges[qEdge],\n                final = node.final && qNode.final,\n                next = undefined;\n\n            if (nEdge in frame.output.edges) {\n              // an edge already exists for this character\n              // no need to create a new node, just set the finality\n              // bit unless this node is already final\n              next = frame.output.edges[nEdge];\n              next.final = next.final || final;\n            } else {\n              // no edge exists yet, must create one\n              // set the finality bit and insert it\n              // into the output\n              next = new lunr.TokenSet();\n              next.final = final;\n              frame.output.edges[nEdge] = next;\n            }\n\n            stack.push({\n              qNode: qNode,\n              output: next,\n              node: node\n            });\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n  lunr.TokenSet.Builder = function () {\n    this.previousWord = \"\";\n    this.root = new lunr.TokenSet();\n    this.uncheckedNodes = [];\n    this.minimizedNodes = {};\n  };\n\n  lunr.TokenSet.Builder.prototype.insert = function (word) {\n    var node,\n        commonPrefix = 0;\n\n    if (word < this.previousWord) {\n      throw new Error(\"Out of order word insertion\");\n    }\n\n    for (var i = 0; i < word.length && i < this.previousWord.length; i++) {\n      if (word[i] != this.previousWord[i]) break;\n      commonPrefix++;\n    }\n\n    this.minimize(commonPrefix);\n\n    if (this.uncheckedNodes.length == 0) {\n      node = this.root;\n    } else {\n      node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;\n    }\n\n    for (var i = commonPrefix; i < word.length; i++) {\n      var nextNode = new lunr.TokenSet(),\n          char = word[i];\n\n      node.edges[char] = nextNode;\n\n      this.uncheckedNodes.push({\n        parent: node,\n        char: char,\n        child: nextNode\n      });\n\n      node = nextNode;\n    }\n\n    node.final = true;\n    this.previousWord = word;\n  };\n\n  lunr.TokenSet.Builder.prototype.finish = function () {\n    this.minimize(0);\n  };\n\n  lunr.TokenSet.Builder.prototype.minimize = function (downTo) {\n    for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {\n      var node = this.uncheckedNodes[i],\n          childKey = node.child.toString();\n\n      if (childKey in this.minimizedNodes) {\n        node.parent.edges[node.char] = this.minimizedNodes[childKey];\n      } else {\n        // Cache the key for this node since\n        // we know it can't change anymore\n        node.child._str = childKey;\n\n        this.minimizedNodes[childKey] = node.child;\n      }\n\n      this.uncheckedNodes.pop();\n    }\n  };\n  /*!\n   * lunr.Index\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * An index contains the built index of all documents and provides a query interface\n   * to the index.\n   *\n   * Usually instances of lunr.Index will not be created using this constructor, instead\n   * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be\n   * used to load previously built and serialized indexes.\n   *\n   * @constructor\n   * @param {Object} attrs - The attributes of the built search index.\n   * @param {Object} attrs.invertedIndex - An index of term/field to document reference.\n   * @param {Object<string, lunr.Vector>} attrs.documentVectors - Document vectors keyed by document reference.\n   * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens.\n   * @param {string[]} attrs.fields - The names of indexed document fields.\n   * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms.\n   */\n  lunr.Index = function (attrs) {\n    this.invertedIndex = attrs.invertedIndex;\n    this.fieldVectors = attrs.fieldVectors;\n    this.tokenSet = attrs.tokenSet;\n    this.fields = attrs.fields;\n    this.pipeline = attrs.pipeline;\n  };\n\n  /**\n   * A result contains details of a document matching a search query.\n   * @typedef {Object} lunr.Index~Result\n   * @property {string} ref - The reference of the document this result represents.\n   * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.\n   * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.\n   */\n\n  /**\n   * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple\n   * query language which itself is parsed into an instance of lunr.Query.\n   *\n   * For programmatically building queries it is advised to directly use lunr.Query, the query language\n   * is best used for human entered text rather than program generated text.\n   *\n   * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported\n   * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'\n   * or 'world', though those that contain both will rank higher in the results.\n   *\n   * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can\n   * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding\n   * wildcards will increase the number of documents that will be found but can also have a negative\n   * impact on query performance, especially with wildcards at the beginning of a term.\n   *\n   * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term\n   * hello in the title field will match this query. Using a field not present in the index will lead\n   * to an error being thrown.\n   *\n   * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term\n   * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported\n   * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.\n   * Avoid large values for edit distance to improve query performance.\n   *\n   * To escape special characters the backslash character '\\' can be used, this allows searches to include\n   * characters that would normally be considered modifiers, e.g. `foo\\~2` will search for a term \"foo~2\" instead\n   * of attempting to apply a boost of 2 to the search term \"foo\".\n   *\n   * @typedef {string} lunr.Index~QueryString\n   * @example <caption>Simple single term query</caption>\n   * hello\n   * @example <caption>Multiple term query</caption>\n   * hello world\n   * @example <caption>term scoped to a field</caption>\n   * title:hello\n   * @example <caption>term with a boost of 10</caption>\n   * hello^10\n   * @example <caption>term with an edit distance of 2</caption>\n   * hello~2\n   */\n\n  /**\n   * Performs a search against the index using lunr query syntax.\n   *\n   * Results will be returned sorted by their score, the most relevant results\n   * will be returned first.\n   *\n   * For more programmatic querying use lunr.Index#query.\n   *\n   * @param {lunr.Index~QueryString} queryString - A string containing a lunr query.\n   * @throws {lunr.QueryParseError} If the passed query string cannot be parsed.\n   * @returns {lunr.Index~Result[]}\n   */\n  lunr.Index.prototype.search = function (queryString) {\n    return this.query(function (query) {\n      var parser = new lunr.QueryParser(queryString, query);\n      parser.parse();\n    });\n  };\n\n  /**\n   * A query builder callback provides a query object to be used to express\n   * the query to perform on the index.\n   *\n   * @callback lunr.Index~queryBuilder\n   * @param {lunr.Query} query - The query object to build up.\n   * @this lunr.Query\n   */\n\n  /**\n   * Performs a query against the index using the yielded lunr.Query object.\n   *\n   * If performing programmatic queries against the index, this method is preferred\n   * over lunr.Index#search so as to avoid the additional query parsing overhead.\n   *\n   * A query object is yielded to the supplied function which should be used to\n   * express the query to be run against the index.\n   *\n   * Note that although this function takes a callback parameter it is _not_ an\n   * asynchronous operation, the callback is just yielded a query object to be\n   * customized.\n   *\n   * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query.\n   * @returns {lunr.Index~Result[]}\n   */\n  lunr.Index.prototype.query = function (fn) {\n    // for each query clause\n    // * process terms\n    // * expand terms from token set\n    // * find matching documents and metadata\n    // * get document vectors\n    // * score documents\n\n    var query = new lunr.Query(this.fields),\n        matchingFields = Object.create(null),\n        queryVectors = Object.create(null),\n        termFieldCache = Object.create(null);\n\n    fn.call(query, query);\n\n    for (var i = 0; i < query.clauses.length; i++) {\n      /*\n       * Unless the pipeline has been disabled for this term, which is\n       * the case for terms with wildcards, we need to pass the clause\n       * term through the search pipeline. A pipeline returns an array\n       * of processed terms. Pipeline functions may expand the passed\n       * term, which means we may end up performing multiple index lookups\n       * for a single query term.\n       */\n      var clause = query.clauses[i],\n          terms = null;\n\n      if (clause.usePipeline) {\n        terms = this.pipeline.runString(clause.term);\n      } else {\n        terms = [clause.term];\n      }\n\n      for (var m = 0; m < terms.length; m++) {\n        var term = terms[m];\n\n        /*\n         * Each term returned from the pipeline needs to use the same query\n         * clause object, e.g. the same boost and or edit distance. The\n         * simplest way to do this is to re-use the clause object but mutate\n         * its term property.\n         */\n        clause.term = term;\n\n        /*\n         * From the term in the clause we create a token set which will then\n         * be used to intersect the indexes token set to get a list of terms\n         * to lookup in the inverted index\n         */\n        var termTokenSet = lunr.TokenSet.fromClause(clause),\n            expandedTerms = this.tokenSet.intersect(termTokenSet).toArray();\n\n        for (var j = 0; j < expandedTerms.length; j++) {\n          /*\n           * For each term get the posting and termIndex, this is required for\n           * building the query vector.\n           */\n          var expandedTerm = expandedTerms[j],\n              posting = this.invertedIndex[expandedTerm],\n              termIndex = posting._index;\n\n          for (var k = 0; k < clause.fields.length; k++) {\n            /*\n             * For each field that this query term is scoped by (by default\n             * all fields are in scope) we need to get all the document refs\n             * that have this term in that field.\n             *\n             * The posting is the entry in the invertedIndex for the matching\n             * term from above.\n             */\n            var field = clause.fields[k],\n                fieldPosting = posting[field],\n                matchingDocumentRefs = Object.keys(fieldPosting),\n                termField = expandedTerm + \"/\" + field;\n\n            /*\n             * To support field level boosts a query vector is created per\n             * field. This vector is populated using the termIndex found for\n             * the term and a unit value with the appropriate boost applied.\n             *\n             * If the query vector for this field does not exist yet it needs\n             * to be created.\n             */\n            if (queryVectors[field] === undefined) {\n              queryVectors[field] = new lunr.Vector();\n            }\n\n            /*\n             * Using upsert because there could already be an entry in the vector\n             * for the term we are working with. In that case we just add the scores\n             * together.\n             */\n            queryVectors[field].upsert(termIndex, 1 * clause.boost, function (a, b) {\n              return a + b;\n            });\n\n            /**\n             * If we've already seen this term, field combo then we've already collected\n             * the matching documents and metadata, no need to go through all that again\n             */\n            if (termFieldCache[termField]) {\n              continue;\n            }\n\n            for (var l = 0; l < matchingDocumentRefs.length; l++) {\n              /*\n               * All metadata for this term/field/document triple\n               * are then extracted and collected into an instance\n               * of lunr.MatchData ready to be returned in the query\n               * results\n               */\n              var matchingDocumentRef = matchingDocumentRefs[l],\n                  matchingFieldRef = new lunr.FieldRef(matchingDocumentRef, field),\n                  metadata = fieldPosting[matchingDocumentRef],\n                  fieldMatch;\n\n              if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {\n                matchingFields[matchingFieldRef] = new lunr.MatchData(expandedTerm, field, metadata);\n              } else {\n                fieldMatch.add(expandedTerm, field, metadata);\n              }\n            }\n\n            termFieldCache[termField] = true;\n          }\n        }\n      }\n    }\n\n    var matchingFieldRefs = Object.keys(matchingFields),\n        results = [],\n        matches = Object.create(null);\n\n    for (var i = 0; i < matchingFieldRefs.length; i++) {\n      /*\n       * Currently we have document fields that match the query, but we\n       * need to return documents. The matchData and scores are combined\n       * from multiple fields belonging to the same document.\n       *\n       * Scores are calculated by field, using the query vectors created\n       * above, and combined into a final document score using addition.\n       */\n      var fieldRef = lunr.FieldRef.fromString(matchingFieldRefs[i]),\n          docRef = fieldRef.docRef,\n          fieldVector = this.fieldVectors[fieldRef],\n          score = queryVectors[fieldRef.fieldName].similarity(fieldVector),\n          docMatch;\n\n      if ((docMatch = matches[docRef]) !== undefined) {\n        docMatch.score += score;\n        docMatch.matchData.combine(matchingFields[fieldRef]);\n      } else {\n        var match = {\n          ref: docRef,\n          score: score,\n          matchData: matchingFields[fieldRef]\n        };\n        matches[docRef] = match;\n        results.push(match);\n      }\n    }\n\n    /*\n     * Sort the results objects by score, highest first.\n     */\n    return results.sort(function (a, b) {\n      return b.score - a.score;\n    });\n  };\n\n  /**\n   * Prepares the index for JSON serialization.\n   *\n   * The schema for this JSON blob will be described in a\n   * separate JSON schema file.\n   *\n   * @returns {Object}\n   */\n  lunr.Index.prototype.toJSON = function () {\n    var invertedIndex = Object.keys(this.invertedIndex).sort().map(function (term) {\n      return [term, this.invertedIndex[term]];\n    }, this);\n\n    var fieldVectors = Object.keys(this.fieldVectors).map(function (ref) {\n      return [ref, this.fieldVectors[ref].toJSON()];\n    }, this);\n\n    return {\n      version: lunr.version,\n      fields: this.fields,\n      fieldVectors: fieldVectors,\n      invertedIndex: invertedIndex,\n      pipeline: this.pipeline.toJSON()\n    };\n  };\n\n  /**\n   * Loads a previously serialized lunr.Index\n   *\n   * @param {Object} serializedIndex - A previously serialized lunr.Index\n   * @returns {lunr.Index}\n   */\n  lunr.Index.load = function (serializedIndex) {\n    var attrs = {},\n        fieldVectors = {},\n        serializedVectors = serializedIndex.fieldVectors,\n        invertedIndex = {},\n        serializedInvertedIndex = serializedIndex.invertedIndex,\n        tokenSetBuilder = new lunr.TokenSet.Builder(),\n        pipeline = lunr.Pipeline.load(serializedIndex.pipeline);\n\n    if (serializedIndex.version != lunr.version) {\n      lunr.utils.warn(\"Version mismatch when loading serialised index. Current version of lunr '\" + lunr.version + \"' does not match serialized index '\" + serializedIndex.version + \"'\");\n    }\n\n    for (var i = 0; i < serializedVectors.length; i++) {\n      var tuple = serializedVectors[i],\n          ref = tuple[0],\n          elements = tuple[1];\n\n      fieldVectors[ref] = new lunr.Vector(elements);\n    }\n\n    for (var i = 0; i < serializedInvertedIndex.length; i++) {\n      var tuple = serializedInvertedIndex[i],\n          term = tuple[0],\n          posting = tuple[1];\n\n      tokenSetBuilder.insert(term);\n      invertedIndex[term] = posting;\n    }\n\n    tokenSetBuilder.finish();\n\n    attrs.fields = serializedIndex.fields;\n\n    attrs.fieldVectors = fieldVectors;\n    attrs.invertedIndex = invertedIndex;\n    attrs.tokenSet = tokenSetBuilder.root;\n    attrs.pipeline = pipeline;\n\n    return new lunr.Index(attrs);\n  };\n  /*!\n   * lunr.Builder\n   * Copyright (C) 2017 Oliver Nightingale\n   */\n\n  /**\n   * lunr.Builder performs indexing on a set of documents and\n   * returns instances of lunr.Index ready for querying.\n   *\n   * All configuration of the index is done via the builder, the\n   * fields to index, the document reference, the text processing\n   * pipeline and document scoring parameters are all set on the\n   * builder before indexing.\n   *\n   * @constructor\n   * @property {string} _ref - Internal reference to the document reference field.\n   * @property {string[]} _fields - Internal reference to the document fields to index.\n   * @property {object} invertedIndex - The inverted index maps terms to document fields.\n   * @property {object} documentTermFrequencies - Keeps track of document term frequencies.\n   * @property {object} documentLengths - Keeps track of the length of documents added to the index.\n   * @property {lunr.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.\n   * @property {lunr.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.\n   * @property {lunr.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.\n   * @property {number} documentCount - Keeps track of the total number of documents indexed.\n   * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.\n   * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.\n   * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.\n   * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.\n   */\n  lunr.Builder = function () {\n    this._ref = \"id\";\n    this._fields = [];\n    this.invertedIndex = Object.create(null);\n    this.fieldTermFrequencies = {};\n    this.fieldLengths = {};\n    this.tokenizer = lunr.tokenizer;\n    this.pipeline = new lunr.Pipeline();\n    this.searchPipeline = new lunr.Pipeline();\n    this.documentCount = 0;\n    this._b = 0.75;\n    this._k1 = 1.2;\n    this.termIndex = 0;\n    this.metadataWhitelist = [];\n  };\n\n  /**\n   * Sets the document field used as the document reference. Every document must have this field.\n   * The type of this field in the document should be a string, if it is not a string it will be\n   * coerced into a string by calling toString.\n   *\n   * The default ref is 'id'.\n   *\n   * The ref should _not_ be changed during indexing, it should be set before any documents are\n   * added to the index. Changing it during indexing can lead to inconsistent results.\n   *\n   * @param {string} ref - The name of the reference field in the document.\n   */\n  lunr.Builder.prototype.ref = function (ref) {\n    this._ref = ref;\n  };\n\n  /**\n   * Adds a field to the list of document fields that will be indexed. Every document being\n   * indexed should have this field. Null values for this field in indexed documents will\n   * not cause errors but will limit the chance of that document being retrieved by searches.\n   *\n   * All fields should be added before adding documents to the index. Adding fields after\n   * a document has been indexed will have no effect on already indexed documents.\n   *\n   * @param {string} field - The name of a field to index in all documents.\n   */\n  lunr.Builder.prototype.field = function (field) {\n    this._fields.push(field);\n  };\n\n  /**\n   * A parameter to tune the amount of field length normalisation that is applied when\n   * calculating relevance scores. A value of 0 will completely disable any normalisation\n   * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b\n   * will be clamped to the range 0 - 1.\n   *\n   * @param {number} number - The value to set for this tuning parameter.\n   */\n  lunr.Builder.prototype.b = function (number) {\n    if (number < 0) {\n      this._b = 0;\n    } else if (number > 1) {\n      this._b = 1;\n    } else {\n      this._b = number;\n    }\n  };\n\n  /**\n   * A parameter that controls the speed at which a rise in term frequency results in term\n   * frequency saturation. The default value is 1.2. Setting this to a higher value will give\n   * slower saturation levels, a lower value will result in quicker saturation.\n   *\n   * @param {number} number - The value to set for this tuning parameter.\n   */\n  lunr.Builder.prototype.k1 = function (number) {\n    this._k1 = number;\n  };\n\n  /**\n   * Adds a document to the index.\n   *\n   * Before adding fields to the index the index should have been fully setup, with the document\n   * ref and all fields to index already having been specified.\n   *\n   * The document must have a field name as specified by the ref (by default this is 'id') and\n   * it should have all fields defined for indexing, though null or undefined values will not\n   * cause errors.\n   *\n   * @param {object} doc - The document to add to the index.\n   */\n  lunr.Builder.prototype.add = function (doc) {\n    var docRef = doc[this._ref];\n\n    this.documentCount += 1;\n\n    for (var i = 0; i < this._fields.length; i++) {\n      var fieldName = this._fields[i],\n          field = doc[fieldName],\n          tokens = this.tokenizer(field),\n          terms = this.pipeline.run(tokens),\n          fieldRef = new lunr.FieldRef(docRef, fieldName),\n          fieldTerms = Object.create(null);\n\n      this.fieldTermFrequencies[fieldRef] = fieldTerms;\n      this.fieldLengths[fieldRef] = 0;\n\n      // store the length of this field for this document\n      this.fieldLengths[fieldRef] += terms.length;\n\n      // calculate term frequencies for this field\n      for (var j = 0; j < terms.length; j++) {\n        var term = terms[j];\n\n        if (fieldTerms[term] == undefined) {\n          fieldTerms[term] = 0;\n        }\n\n        fieldTerms[term] += 1;\n\n        // add to inverted index\n        // create an initial posting if one doesn't exist\n        if (this.invertedIndex[term] == undefined) {\n          var posting = Object.create(null);\n          posting[\"_index\"] = this.termIndex;\n          this.termIndex += 1;\n\n          for (var k = 0; k < this._fields.length; k++) {\n            posting[this._fields[k]] = Object.create(null);\n          }\n\n          this.invertedIndex[term] = posting;\n        }\n\n        // add an entry for this term/fieldName/docRef to the invertedIndex\n        if (this.invertedIndex[term][fieldName][docRef] == undefined) {\n          this.invertedIndex[term][fieldName][docRef] = Object.create(null);\n        }\n\n        // store all whitelisted metadata about this token in the\n        // inverted index\n        for (var l = 0; l < this.metadataWhitelist.length; l++) {\n          var metadataKey = this.metadataWhitelist[l],\n              metadata = term.metadata[metadataKey];\n\n          if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {\n            this.invertedIndex[term][fieldName][docRef][metadataKey] = [];\n          }\n\n          this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata);\n        }\n      }\n    }\n  };\n\n  /**\n   * Calculates the average document length for this index\n   *\n   * @private\n   */\n  lunr.Builder.prototype.calculateAverageFieldLengths = function () {\n\n    var fieldRefs = Object.keys(this.fieldLengths),\n        numberOfFields = fieldRefs.length,\n        accumulator = {},\n        documentsWithField = {};\n\n    for (var i = 0; i < numberOfFields; i++) {\n      var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),\n          field = fieldRef.fieldName;\n\n      documentsWithField[field] || (documentsWithField[field] = 0);\n      documentsWithField[field] += 1;\n\n      accumulator[field] || (accumulator[field] = 0);\n      accumulator[field] += this.fieldLengths[fieldRef];\n    }\n\n    for (var i = 0; i < this._fields.length; i++) {\n      var field = this._fields[i];\n      accumulator[field] = accumulator[field] / documentsWithField[field];\n    }\n\n    this.averageFieldLength = accumulator;\n  };\n\n  /**\n   * Builds a vector space model of every document using lunr.Vector\n   *\n   * @private\n   */\n  lunr.Builder.prototype.createFieldVectors = function () {\n    var fieldVectors = {},\n        fieldRefs = Object.keys(this.fieldTermFrequencies),\n        fieldRefsLength = fieldRefs.length,\n        termIdfCache = Object.create(null);\n\n    for (var i = 0; i < fieldRefsLength; i++) {\n      var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),\n          field = fieldRef.fieldName,\n          fieldLength = this.fieldLengths[fieldRef],\n          fieldVector = new lunr.Vector(),\n          termFrequencies = this.fieldTermFrequencies[fieldRef],\n          terms = Object.keys(termFrequencies),\n          termsLength = terms.length;\n\n      for (var j = 0; j < termsLength; j++) {\n        var term = terms[j],\n            tf = termFrequencies[term],\n            termIndex = this.invertedIndex[term]._index,\n            idf,\n            score,\n            scoreWithPrecision;\n\n        if (termIdfCache[term] === undefined) {\n          idf = lunr.idf(this.invertedIndex[term], this.documentCount);\n          termIdfCache[term] = idf;\n        } else {\n          idf = termIdfCache[term];\n        }\n\n        score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[field])) + tf);\n        scoreWithPrecision = Math.round(score * 1000) / 1000;\n        // Converts 1.23456789 to 1.234.\n        // Reducing the precision so that the vectors take up less\n        // space when serialised. Doing it now so that they behave\n        // the same before and after serialisation. Also, this is\n        // the fastest approach to reducing a number's precision in\n        // JavaScript.\n\n        fieldVector.insert(termIndex, scoreWithPrecision);\n      }\n\n      fieldVectors[fieldRef] = fieldVector;\n    }\n\n    this.fieldVectors = fieldVectors;\n  };\n\n  /**\n   * Creates a token set of all tokens in the index using lunr.TokenSet\n   *\n   * @private\n   */\n  lunr.Builder.prototype.createTokenSet = function () {\n    this.tokenSet = lunr.TokenSet.fromArray(Object.keys(this.invertedIndex).sort());\n  };\n\n  /**\n   * Builds the index, creating an instance of lunr.Index.\n   *\n   * This completes the indexing process and should only be called\n   * once all documents have been added to the index.\n   *\n   * @returns {lunr.Index}\n   */\n  lunr.Builder.prototype.build = function () {\n    this.calculateAverageFieldLengths();\n    this.createFieldVectors();\n    this.createTokenSet();\n\n    return new lunr.Index({\n      invertedIndex: this.invertedIndex,\n      fieldVectors: this.fieldVectors,\n      tokenSet: this.tokenSet,\n      fields: this._fields,\n      pipeline: this.searchPipeline\n    });\n  };\n\n  /**\n   * Applies a plugin to the index builder.\n   *\n   * A plugin is a function that is called with the index builder as its context.\n   * Plugins can be used to customise or extend the behaviour of the index\n   * in some way. A plugin is just a function, that encapsulated the custom\n   * behaviour that should be applied when building the index.\n   *\n   * The plugin function will be called with the index builder as its argument, additional\n   * arguments can also be passed when calling use. The function will be called\n   * with the index builder as its context.\n   *\n   * @param {Function} plugin The plugin to apply.\n   */\n  lunr.Builder.prototype.use = function (fn) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    args.unshift(this);\n    fn.apply(this, args);\n  };\n  /**\n   * Contains and collects metadata about a matching document.\n   * A single instance of lunr.MatchData is returned as part of every\n   * lunr.Index~Result.\n   *\n   * @constructor\n   * @param {string} term - The term this match data is associated with\n   * @param {string} field - The field in which the term was found\n   * @param {object} metadata - The metadata recorded about this term in this field\n   * @property {object} metadata - A cloned collection of metadata associated with this document.\n   * @see {@link lunr.Index~Result}\n   */\n  lunr.MatchData = function (term, field, metadata) {\n    var clonedMetadata = Object.create(null),\n        metadataKeys = Object.keys(metadata);\n\n    // Cloning the metadata to prevent the original\n    // being mutated during match data combination.\n    // Metadata is kept in an array within the inverted\n    // index so cloning the data can be done with\n    // Array#slice\n    for (var i = 0; i < metadataKeys.length; i++) {\n      var key = metadataKeys[i];\n      clonedMetadata[key] = metadata[key].slice();\n    }\n\n    this.metadata = Object.create(null);\n    this.metadata[term] = Object.create(null);\n    this.metadata[term][field] = clonedMetadata;\n  };\n\n  /**\n   * An instance of lunr.MatchData will be created for every term that matches a\n   * document. However only one instance is required in a lunr.Index~Result. This\n   * method combines metadata from another instance of lunr.MatchData with this\n   * objects metadata.\n   *\n   * @param {lunr.MatchData} otherMatchData - Another instance of match data to merge with this one.\n   * @see {@link lunr.Index~Result}\n   */\n  lunr.MatchData.prototype.combine = function (otherMatchData) {\n    var terms = Object.keys(otherMatchData.metadata);\n\n    for (var i = 0; i < terms.length; i++) {\n      var term = terms[i],\n          fields = Object.keys(otherMatchData.metadata[term]);\n\n      if (this.metadata[term] == undefined) {\n        this.metadata[term] = Object.create(null);\n      }\n\n      for (var j = 0; j < fields.length; j++) {\n        var field = fields[j],\n            keys = Object.keys(otherMatchData.metadata[term][field]);\n\n        if (this.metadata[term][field] == undefined) {\n          this.metadata[term][field] = Object.create(null);\n        }\n\n        for (var k = 0; k < keys.length; k++) {\n          var key = keys[k];\n\n          if (this.metadata[term][field][key] == undefined) {\n            this.metadata[term][field][key] = otherMatchData.metadata[term][field][key];\n          } else {\n            this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key]);\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Add metadata for a term/field pair to this instance of match data.\n   *\n   * @param {string} term - The term this match data is associated with\n   * @param {string} field - The field in which the term was found\n   * @param {object} metadata - The metadata recorded about this term in this field\n   */\n  lunr.MatchData.prototype.add = function (term, field, metadata) {\n    if (!(term in this.metadata)) {\n      this.metadata[term] = Object.create(null);\n      this.metadata[term][field] = metadata;\n      return;\n    }\n\n    if (!(field in this.metadata[term])) {\n      this.metadata[term][field] = metadata;\n      return;\n    }\n\n    var metadataKeys = Object.keys(metadata);\n\n    for (var i = 0; i < metadataKeys.length; i++) {\n      var key = metadataKeys[i];\n\n      if (key in this.metadata[term][field]) {\n        this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key]);\n      } else {\n        this.metadata[term][field][key] = metadata[key];\n      }\n    }\n  };\n  /**\n   * A lunr.Query provides a programmatic way of defining queries to be performed\n   * against a {@link lunr.Index}.\n   *\n   * Prefer constructing a lunr.Query using the {@link lunr.Index#query} method\n   * so the query object is pre-initialized with the right index fields.\n   *\n   * @constructor\n   * @property {lunr.Query~Clause[]} clauses - An array of query clauses.\n   * @property {string[]} allFields - An array of all available fields in a lunr.Index.\n   */\n  lunr.Query = function (allFields) {\n    this.clauses = [];\n    this.allFields = allFields;\n  };\n\n  /**\n   * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.\n   *\n   * This allows wildcards to be added to the beginning and end of a term without having to manually do any string\n   * concatenation.\n   *\n   * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.\n   *\n   * @constant\n   * @default\n   * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour\n   * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists\n   * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists\n   * @see lunr.Query~Clause\n   * @see lunr.Query#clause\n   * @see lunr.Query#term\n   * @example <caption>query term with trailing wildcard</caption>\n   * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING })\n   * @example <caption>query term with leading and trailing wildcard</caption>\n   * query.term('foo', {\n   *   wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING\n   * })\n   */\n  lunr.Query.wildcard = new String(\"*\");\n  lunr.Query.wildcard.NONE = 0;\n  lunr.Query.wildcard.LEADING = 1;\n  lunr.Query.wildcard.TRAILING = 2;\n\n  /**\n   * A single clause in a {@link lunr.Query} contains a term and details on how to\n   * match that term against a {@link lunr.Index}.\n   *\n   * @typedef {Object} lunr.Query~Clause\n   * @property {string[]} fields - The fields in an index this clause should be matched against.\n   * @property {number} [boost=1] - Any boost that should be applied when matching this clause.\n   * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.\n   * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.\n   * @property {number} [wildcard=0] - Whether the term should have wildcards appended or prepended.\n   */\n\n  /**\n   * Adds a {@link lunr.Query~Clause} to this query.\n   *\n   * Unless the clause contains the fields to be matched all fields will be matched. In addition\n   * a default boost of 1 is applied to the clause.\n   *\n   * @param {lunr.Query~Clause} clause - The clause to add to this query.\n   * @see lunr.Query~Clause\n   * @returns {lunr.Query}\n   */\n  lunr.Query.prototype.clause = function (clause) {\n    if (!('fields' in clause)) {\n      clause.fields = this.allFields;\n    }\n\n    if (!('boost' in clause)) {\n      clause.boost = 1;\n    }\n\n    if (!('usePipeline' in clause)) {\n      clause.usePipeline = true;\n    }\n\n    if (!('wildcard' in clause)) {\n      clause.wildcard = lunr.Query.wildcard.NONE;\n    }\n\n    if (clause.wildcard & lunr.Query.wildcard.LEADING && clause.term.charAt(0) != lunr.Query.wildcard) {\n      clause.term = \"*\" + clause.term;\n    }\n\n    if (clause.wildcard & lunr.Query.wildcard.TRAILING && clause.term.slice(-1) != lunr.Query.wildcard) {\n      clause.term = \"\" + clause.term + \"*\";\n    }\n\n    this.clauses.push(clause);\n\n    return this;\n  };\n\n  /**\n   * Adds a term to the current query, under the covers this will create a {@link lunr.Query~Clause}\n   * to the list of clauses that make up this query.\n   *\n   * @param {string} term - The term to add to the query.\n   * @param {Object} [options] - Any additional properties to add to the query clause.\n   * @returns {lunr.Query}\n   * @see lunr.Query#clause\n   * @see lunr.Query~Clause\n   * @example <caption>adding a single term to a query</caption>\n   * query.term(\"foo\")\n   * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>\n   * query.term(\"foo\", {\n   *   fields: [\"title\"],\n   *   boost: 10,\n   *   wildcard: lunr.Query.wildcard.TRAILING\n   * })\n   */\n  lunr.Query.prototype.term = function (term, options) {\n    var clause = options || {};\n    clause.term = term;\n\n    this.clause(clause);\n\n    return this;\n  };\n  lunr.QueryParseError = function (message, start, end) {\n    this.name = \"QueryParseError\";\n    this.message = message;\n    this.start = start;\n    this.end = end;\n  };\n\n  lunr.QueryParseError.prototype = new Error();\n  lunr.QueryLexer = function (str) {\n    this.lexemes = [];\n    this.str = str;\n    this.length = str.length;\n    this.pos = 0;\n    this.start = 0;\n    this.escapeCharPositions = [];\n  };\n\n  lunr.QueryLexer.prototype.run = function () {\n    var state = lunr.QueryLexer.lexText;\n\n    while (state) {\n      state = state(this);\n    }\n  };\n\n  lunr.QueryLexer.prototype.sliceString = function () {\n    var subSlices = [],\n        sliceStart = this.start,\n        sliceEnd = this.pos;\n\n    for (var i = 0; i < this.escapeCharPositions.length; i++) {\n      sliceEnd = this.escapeCharPositions[i];\n      subSlices.push(this.str.slice(sliceStart, sliceEnd));\n      sliceStart = sliceEnd + 1;\n    }\n\n    subSlices.push(this.str.slice(sliceStart, this.pos));\n    this.escapeCharPositions.length = 0;\n\n    return subSlices.join('');\n  };\n\n  lunr.QueryLexer.prototype.emit = function (type) {\n    this.lexemes.push({\n      type: type,\n      str: this.sliceString(),\n      start: this.start,\n      end: this.pos\n    });\n\n    this.start = this.pos;\n  };\n\n  lunr.QueryLexer.prototype.escapeCharacter = function () {\n    this.escapeCharPositions.push(this.pos - 1);\n    this.pos += 1;\n  };\n\n  lunr.QueryLexer.prototype.next = function () {\n    if (this.pos >= this.length) {\n      return lunr.QueryLexer.EOS;\n    }\n\n    var char = this.str.charAt(this.pos);\n    this.pos += 1;\n    return char;\n  };\n\n  lunr.QueryLexer.prototype.width = function () {\n    return this.pos - this.start;\n  };\n\n  lunr.QueryLexer.prototype.ignore = function () {\n    if (this.start == this.pos) {\n      this.pos += 1;\n    }\n\n    this.start = this.pos;\n  };\n\n  lunr.QueryLexer.prototype.backup = function () {\n    this.pos -= 1;\n  };\n\n  lunr.QueryLexer.prototype.acceptDigitRun = function () {\n    var char, charCode;\n\n    do {\n      char = this.next();\n      charCode = char.charCodeAt(0);\n    } while (charCode > 47 && charCode < 58);\n\n    if (char != lunr.QueryLexer.EOS) {\n      this.backup();\n    }\n  };\n\n  lunr.QueryLexer.prototype.more = function () {\n    return this.pos < this.length;\n  };\n\n  lunr.QueryLexer.EOS = 'EOS';\n  lunr.QueryLexer.FIELD = 'FIELD';\n  lunr.QueryLexer.TERM = 'TERM';\n  lunr.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE';\n  lunr.QueryLexer.BOOST = 'BOOST';\n\n  lunr.QueryLexer.lexField = function (lexer) {\n    lexer.backup();\n    lexer.emit(lunr.QueryLexer.FIELD);\n    lexer.ignore();\n    return lunr.QueryLexer.lexText;\n  };\n\n  lunr.QueryLexer.lexTerm = function (lexer) {\n    if (lexer.width() > 1) {\n      lexer.backup();\n      lexer.emit(lunr.QueryLexer.TERM);\n    }\n\n    lexer.ignore();\n\n    if (lexer.more()) {\n      return lunr.QueryLexer.lexText;\n    }\n  };\n\n  lunr.QueryLexer.lexEditDistance = function (lexer) {\n    lexer.ignore();\n    lexer.acceptDigitRun();\n    lexer.emit(lunr.QueryLexer.EDIT_DISTANCE);\n    return lunr.QueryLexer.lexText;\n  };\n\n  lunr.QueryLexer.lexBoost = function (lexer) {\n    lexer.ignore();\n    lexer.acceptDigitRun();\n    lexer.emit(lunr.QueryLexer.BOOST);\n    return lunr.QueryLexer.lexText;\n  };\n\n  lunr.QueryLexer.lexEOS = function (lexer) {\n    if (lexer.width() > 0) {\n      lexer.emit(lunr.QueryLexer.TERM);\n    }\n  };\n\n  // This matches the separator used when tokenising fields\n  // within a document. These should match otherwise it is\n  // not possible to search for some tokens within a document.\n  //\n  // It is possible for the user to change the separator on the\n  // tokenizer so it _might_ clash with any other of the special\n  // characters already used within the search string, e.g. :.\n  //\n  // This means that it is possible to change the separator in\n  // such a way that makes some words unsearchable using a search\n  // string.\n  lunr.QueryLexer.termSeparator = lunr.tokenizer.separator;\n\n  lunr.QueryLexer.lexText = function (lexer) {\n    while (true) {\n      var char = lexer.next();\n\n      if (char == lunr.QueryLexer.EOS) {\n        return lunr.QueryLexer.lexEOS;\n      }\n\n      // Escape character is '\\'\n      if (char.charCodeAt(0) == 92) {\n        lexer.escapeCharacter();\n        continue;\n      }\n\n      if (char == \":\") {\n        return lunr.QueryLexer.lexField;\n      }\n\n      if (char == \"~\") {\n        lexer.backup();\n        if (lexer.width() > 0) {\n          lexer.emit(lunr.QueryLexer.TERM);\n        }\n        return lunr.QueryLexer.lexEditDistance;\n      }\n\n      if (char == \"^\") {\n        lexer.backup();\n        if (lexer.width() > 0) {\n          lexer.emit(lunr.QueryLexer.TERM);\n        }\n        return lunr.QueryLexer.lexBoost;\n      }\n\n      if (char.match(lunr.QueryLexer.termSeparator)) {\n        return lunr.QueryLexer.lexTerm;\n      }\n    }\n  };\n\n  lunr.QueryParser = function (str, query) {\n    this.lexer = new lunr.QueryLexer(str);\n    this.query = query;\n    this.currentClause = {};\n    this.lexemeIdx = 0;\n  };\n\n  lunr.QueryParser.prototype.parse = function () {\n    this.lexer.run();\n    this.lexemes = this.lexer.lexemes;\n\n    var state = lunr.QueryParser.parseFieldOrTerm;\n\n    while (state) {\n      state = state(this);\n    }\n\n    return this.query;\n  };\n\n  lunr.QueryParser.prototype.peekLexeme = function () {\n    return this.lexemes[this.lexemeIdx];\n  };\n\n  lunr.QueryParser.prototype.consumeLexeme = function () {\n    var lexeme = this.peekLexeme();\n    this.lexemeIdx += 1;\n    return lexeme;\n  };\n\n  lunr.QueryParser.prototype.nextClause = function () {\n    var completedClause = this.currentClause;\n    this.query.clause(completedClause);\n    this.currentClause = {};\n  };\n\n  lunr.QueryParser.parseFieldOrTerm = function (parser) {\n    var lexeme = parser.peekLexeme();\n\n    if (lexeme == undefined) {\n      return;\n    }\n\n    switch (lexeme.type) {\n      case lunr.QueryLexer.FIELD:\n        return lunr.QueryParser.parseField;\n      case lunr.QueryLexer.TERM:\n        return lunr.QueryParser.parseTerm;\n      default:\n        var errorMessage = \"expected either a field or a term, found \" + lexeme.type;\n\n        if (lexeme.str.length >= 1) {\n          errorMessage += \" with value '\" + lexeme.str + \"'\";\n        }\n\n        throw new lunr.QueryParseError(errorMessage, lexeme.start, lexeme.end);\n    }\n  };\n\n  lunr.QueryParser.parseField = function (parser) {\n    var lexeme = parser.consumeLexeme();\n\n    if (lexeme == undefined) {\n      return;\n    }\n\n    if (parser.query.allFields.indexOf(lexeme.str) == -1) {\n      var possibleFields = parser.query.allFields.map(function (f) {\n        return \"'\" + f + \"'\";\n      }).join(', '),\n          errorMessage = \"unrecognised field '\" + lexeme.str + \"', possible fields: \" + possibleFields;\n\n      throw new lunr.QueryParseError(errorMessage, lexeme.start, lexeme.end);\n    }\n\n    parser.currentClause.fields = [lexeme.str];\n\n    var nextLexeme = parser.peekLexeme();\n\n    if (nextLexeme == undefined) {\n      var errorMessage = \"expecting term, found nothing\";\n      throw new lunr.QueryParseError(errorMessage, lexeme.start, lexeme.end);\n    }\n\n    switch (nextLexeme.type) {\n      case lunr.QueryLexer.TERM:\n        return lunr.QueryParser.parseTerm;\n      default:\n        var errorMessage = \"expecting term, found '\" + nextLexeme.type + \"'\";\n        throw new lunr.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);\n    }\n  };\n\n  lunr.QueryParser.parseTerm = function (parser) {\n    var lexeme = parser.consumeLexeme();\n\n    if (lexeme == undefined) {\n      return;\n    }\n\n    parser.currentClause.term = lexeme.str.toLowerCase();\n\n    if (lexeme.str.indexOf(\"*\") != -1) {\n      parser.currentClause.usePipeline = false;\n    }\n\n    var nextLexeme = parser.peekLexeme();\n\n    if (nextLexeme == undefined) {\n      parser.nextClause();\n      return;\n    }\n\n    switch (nextLexeme.type) {\n      case lunr.QueryLexer.TERM:\n        parser.nextClause();\n        return lunr.QueryParser.parseTerm;\n      case lunr.QueryLexer.FIELD:\n        parser.nextClause();\n        return lunr.QueryParser.parseField;\n      case lunr.QueryLexer.EDIT_DISTANCE:\n        return lunr.QueryParser.parseEditDistance;\n      case lunr.QueryLexer.BOOST:\n        return lunr.QueryParser.parseBoost;\n      default:\n        var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\";\n        throw new lunr.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);\n    }\n  };\n\n  lunr.QueryParser.parseEditDistance = function (parser) {\n    var lexeme = parser.consumeLexeme();\n\n    if (lexeme == undefined) {\n      return;\n    }\n\n    var editDistance = parseInt(lexeme.str, 10);\n\n    if (isNaN(editDistance)) {\n      var errorMessage = \"edit distance must be numeric\";\n      throw new lunr.QueryParseError(errorMessage, lexeme.start, lexeme.end);\n    }\n\n    parser.currentClause.editDistance = editDistance;\n\n    var nextLexeme = parser.peekLexeme();\n\n    if (nextLexeme == undefined) {\n      parser.nextClause();\n      return;\n    }\n\n    switch (nextLexeme.type) {\n      case lunr.QueryLexer.TERM:\n        parser.nextClause();\n        return lunr.QueryParser.parseTerm;\n      case lunr.QueryLexer.FIELD:\n        parser.nextClause();\n        return lunr.QueryParser.parseField;\n      case lunr.QueryLexer.EDIT_DISTANCE:\n        return lunr.QueryParser.parseEditDistance;\n      case lunr.QueryLexer.BOOST:\n        return lunr.QueryParser.parseBoost;\n      default:\n        var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\";\n        throw new lunr.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);\n    }\n  };\n\n  lunr.QueryParser.parseBoost = function (parser) {\n    var lexeme = parser.consumeLexeme();\n\n    if (lexeme == undefined) {\n      return;\n    }\n\n    var boost = parseInt(lexeme.str, 10);\n\n    if (isNaN(boost)) {\n      var errorMessage = \"boost must be numeric\";\n      throw new lunr.QueryParseError(errorMessage, lexeme.start, lexeme.end);\n    }\n\n    parser.currentClause.boost = boost;\n\n    var nextLexeme = parser.peekLexeme();\n\n    if (nextLexeme == undefined) {\n      parser.nextClause();\n      return;\n    }\n\n    switch (nextLexeme.type) {\n      case lunr.QueryLexer.TERM:\n        parser.nextClause();\n        return lunr.QueryParser.parseTerm;\n      case lunr.QueryLexer.FIELD:\n        parser.nextClause();\n        return lunr.QueryParser.parseField;\n      case lunr.QueryLexer.EDIT_DISTANCE:\n        return lunr.QueryParser.parseEditDistance;\n      case lunr.QueryLexer.BOOST:\n        return lunr.QueryParser.parseBoost;\n      default:\n        var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\";\n        throw new lunr.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);\n    }\n  }\n\n  /**\n   * export the module via AMD, CommonJS or as a browser global\n   * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js\n   */\n  ;(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      // AMD. Register as an anonymous module.\n      define(factory);\n    } else if (typeof exports === 'object') {\n      /**\n       * Node. Does not work with strict CommonJS, but\n       * only CommonJS-like enviroments that support module.exports,\n       * like Node.\n       */\n      module.exports = factory();\n    } else {\n      // Browser globals (root is window)\n      root.lunr = factory();\n    }\n  })(this, function () {\n    /**\n     * Just return a value to define the module export.\n     * This example returns an object, but the module\n     * can return a function as the exported value.\n     */\n    return lunr;\n  });\n})();\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n//# sourceMappingURL=maps/lunr.js.map\n"]}